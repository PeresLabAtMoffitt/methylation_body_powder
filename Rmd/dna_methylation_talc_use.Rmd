---
title: "Genital powder/talc exposure and tumor DNAm profiles"
author: "Christelle Colin-Leitzinger"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    theme: united
    highlight: pygments
    df_print: paged
    code_folding: hide
editor_options:
  chunk_output_type: console
---

<style type= "text/css">

. figure {
   margin-top: 25px;
   margin-bottom: 100px;
}

table {
    margin-top: 10px;
    margin-bottom: 25px;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      cache = FALSE,
                      fig.align='center'
                      )
```

```{r library}
library(here)
library(tidyverse)
library(gtsummary)
library(labelled)
library(plotly)
library(minfi)
library(limma) # for lmFit
library(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
library(DMRcate)
library(EnhancedVolcano)
library(ComplexHeatmap)
theme_set(theme_classic())
theme_gtsummary_compact()
```

```{r load}

load(paste0(here::here(), 
            "/data/raw data",
            "/cleaned_07082022.rda"))
load(paste0(here::here(), 
            "/data/raw data",
            "/annotationEPICb5updated3.rda"))

clock_data <-
  read_rds(paste0(here(), 
                  "/data/processed data",
                  "/clock_data.rds")) %>% 
  mutate(diagyear_cat = case_when(
    diagyear < 2000            ~ "<2000",
    diagyear >= 2000 &
      diagyear < 2005          ~ "2000-2004",
    diagyear >= 2005 &
      diagyear < 2010          ~ "2005-2009",
    diagyear >= 2010           ~ "≥2010"
  ), diagyear_cat = factor(diagyear_cat, levels = c("<2000", "2000-2004",
                                                    "2005-2009", "≥2010"))) %>% 
  left_join(., phenoclean %>% 
              select(suid = Sample_Name, debulking_CA125), 
            by = "suid") %>% 
  mutate(stage_cat = factor(stage_cat, 
                            levels = c("Early", 
                                       "Late"))) %>% 
  mutate(debulking_CA125 = factor(debulking_CA125, 
                                  levels = c("OPTIMAL", 
                                             "SUBOPTIMAL")))
```


# DNA data exploration
The original clean (filtered and normalized) data contains `r nrow(betas_clean6)` CpGs information on `r ncol(betas_clean6)` patients.
<!-- This is a quick view of 3 samples/6 CpGs. -->
<!-- ```{r} -->
<!-- betas_clean6[,1:3] %>% head() -->
<!-- ``` -->
<!-- <br> -->

## 1. Missingness
Some patients have higher level of missingness.
```{r}
a <- skimr::skim(betas_clean6)
a %>% as_tibble()
```

Patients % missing in final data
```{r Missingness rate}
betas_clean6_df <- betas_clean6 %>% as_tibble(rownames = "cpgs_id")
betas_clean6_df1 <- betas_clean6_df %>%
  column_to_rownames("cpgs_id")
# betas_clean6_df1 %>% summarise_all(list(name = ~sum(is.na(.))/length(.)))

missing_summary <- betas_clean6_df1 %>% summarise_all(list(name = ~sum(is.na(.))/length(.) * 100))
plot <- missing_summary %>%
  pivot_longer(everything(),
               values_to = "Percent missing") %>%
  mutate(text = paste("Patient: ", name, "\nPercent missing: ", round(`Percent missing`, 1), sep="")) %>%
  ggplot(aes(x= name, y= `Percent missing`, color= name, text=text))+
  geom_point()+
  geom_segment(aes(xend= name, yend= 0))+
  labs(x = "Patients \nhover over the points to see information")+
  theme(legend.position = "none",
        axis.text.x = element_blank())

plot <- ggplotly(plot, tooltip="text")
plot
```
Missingness rate for the overall data is `r round(mean(is.na(betas_clean6_df1)) * 100, 1)`%
<br>

## 2. Outliers
I am running the same outlier detection code as for the RE paper but using the overall methylation data this time to see if samples need to be excluded.
```{r outlier detection code, echo=TRUE, class.source = 'fold-hide'}
beta = betas_clean6_df1
qq = apply(beta, 2, function(x) quantile(x, probs = c(0.25, 
                                                      0.5, 0.75), na.rm = TRUE))
q2575 <- apply(qq, 1, function(x) quantile(x, probs = c(0.25, 
                                                        0.75), na.rm = TRUE))
qr <- q2575["75%", ] - q2575["25%", ]
up = q2575["75%", ] + 3 * qr
low = q2575["25%", ] - 3 * qr
flag = qq > up | qq < low
flag = apply(flag, 2, sum) > 0
```

```{r outliers}
outliers <- names(flag[flag %in% c("TRUE")])
```
`r sum(flag)` samples are outliers in beta value distribution
(`r paste(outliers, collapse = " and ")`).   
The outliers DNA methylation distribution are depicted in black in the density plot below

```{r plot outliers}
rm(beta, q2575, qq, flag, low, qr, up)
plot <-
  betas_clean6_df %>%
  pivot_longer(cols = -cpgs_id) %>%
  ggplot(aes(x= value, color= name))+
  geom_density(linetype = 2)+
  # geom_density(data = a, aes(x= value, linetype = name), color = "black")+
  geom_density(data = betas_clean6_df %>% select(value = all_of(outliers[1])), aes(x= value), color = "black")+
  geom_density(data = betas_clean6_df %>% select(value = all_of(outliers[2])), aes(x= value), color = "black")+
  xlim(0,1)+
  theme(legend.position = "none")
plot
```

and depicted in green below. In orange are 4 examples of non-outliers distributions.
```{r bean plot outliers}
plot <- betas_clean6_df %>% select(colnames(betas_clean6_df)[2:5], all_of(outliers)) %>% as.matrix()
densityBeanPlot(plot, sampGroups = c("included", "included", "included", "included", "excluded", "excluded"))
```
<br>






# DNA methylation analysis
## 1. Data preparation
```{r exclude patient with missing values for variable of interest}
missing_talc_info_id <- clock_data %>% filter(is.na(talcgen)) %>% select(Complete.Barcode)
missing_talc_info_id <- missing_talc_info_id$Complete.Barcode
```
Patient exclusion:    
- patient with missing genital talc powder use info, N = `r length(missing_talc_info_id)`, ids = `r missing_talc_info_id`    
- patient with outlier B value distribution, N = `r length(outliers)`, ids = `r outliers`    
```{r remove excluded patient}
betas_clean6 <- betas_clean6[, !colnames(betas_clean6) %in% c(missing_talc_info_id)]
betas_clean6 <- betas_clean6[, !colnames(betas_clean6) %in% c(outliers)]
phenoclean_subset <- phenoclean %>% 
  filter(!str_detect(Complete.Barcode, 
                     paste0(c(missing_talc_info_id), 
                            collapse = "|"))) %>% 
  filter(!str_detect(Complete.Barcode, 
                     paste0(c(outliers), 
                            collapse = "|"))) %>% 
  left_join(., clock_data %>% 
              select(suid, talcgen), 
            by = c("Sample_Name" = "suid"))
clock_data <- clock_data %>% 
  filter(!str_detect(Complete.Barcode, 
                     paste0(c(missing_talc_info_id), 
                            collapse = "|"))) %>% 
  filter(!str_detect(Complete.Barcode, 
                     paste0(c(outliers), 
                            collapse = "|")))

# complete_case <- clock_data %>% 
#   filter(!is.na(stage_cat) & 
#            !is.na(debulking_CA125) & 
#            !is.na(refage))
# complete_case_id <- complete_case %>% select(Complete.Barcode)
# complete_case_id <- complete_case_id$Complete.Barcode

# betas_clean6_complete <- betas_clean6[, colnames(betas_clean6) %in% c(complete_case_id)]
# phenoclean_complete <- phenoclean %>% 
#   filter(str_detect(Complete.Barcode, 
#                     paste0(c(complete_case_id), 
#                            collapse = "|")))
```
Patient included, N = `r nrow(phenoclean_subset)`.    
<br>

# I. Probe-wise differential methylation analysis
The biological question of interest for this particular dataset is to discover differentially methylated probes between patients using or not genital powder.   
The analysis is performed using the B values and as a start we are building a model only including the intercept and genital powder use. Since it performs a comparison on very high numbers of CpGs, adjust the p-values for multiple testing are included.   


## Using a simple model (intercept + talgen)
### A. Fit and look at the numbers of DM CpGs at FDR < 0.05
```{r dmps, echo=TRUE, class.source = 'fold-hide'}
# # this is the factor of interest
variable <- factor(clock_data$talcgen) # No , Yes
# cellType <- factor(targets$Sample_Group) # Original code
# # this is the individual effect that we need to account for
# individual <- factor(targets$Sample_Source)

# use the above to create a design matrix
design <- model.matrix(~1 + talcgen, data = clock_data)
# colnames(design) <- c(levels(cellType),levels(individual)[-1]) # Original
colnames(design) <- c(levels(variable)) 

# fit the linear model
set.seed(1234)
fit <- lmFit(betas_clean6, design)
# write_rds(fit, paste0(here::here(),
#                       "/results/fit_from_lmFit_simple_model_", today(), ".rds"))
# fit <- read_rds("results/fit_from_lmFit_simple_model_2025-09-24.rds")

# # create a contrast matrix for specific comparisons # NOT RUN for simple model---
# contMatrix <- makeContrasts(naive-rTreg,
#                            naive-act_naive,
#                            rTreg-act_rTreg,
#                            act_naive-act_rTreg,
#                            levels=design)
# contMatrix
# 
# # fit the contrasts
# fit2 <- contrasts.fit(fit, contMatrix)
set.seed(1234)
fit2 <- eBayes(fit)# eBayes(fit2)

# look at the numbers of DM CpGs at FDR < 0.05
summary(decideTests(fit2))
```
It seems we don't detect any significant methylation change for patients using genital body powder.   
<br>

### B. Annotation
I am using the new annotation file from Lucas to run the DMP. See below for results.
```{r annotatedmps}
# # ann450k = getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19) # Original code
# # head(ann450k, 2)
# anno_EPIC = getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
# # head(anno_EPIC, 2)
# # tail(anno_EPIC, 2)
# 
# # get the table of results for the first contrast (naive - rTreg)
# # ann450kSub <- ann450k[match(rownames(mVals),ann450k$Name), # Original code
# #                          c(1:4,12:19,24:ncol(ann450k))]
# 
# # anno_EPIC has rownames like "cg25324105_BC11", "cg25383568_TC11"
# # need to extract the CpGs name frist
# anno_EPIC$Name_ <- str_match(anno_EPIC$Name, "(.*)_")[,2] # "cg25324105" "cg25383568" "cg25455143" "cg25459778"
# 
# # match(rownames(betas_clean6),anno_EPIC$Name_) # 601957
# # rownames(betas_clean6)[15]
# # [1] "cg00000734"
# # match("cg00000734",anno_EPIC$Name_)
# # match("cg00000734",c("cg00000734", anno_EPIC$Name_))
# # So some rownames in beta_clean6 are not present in anno_EPIC???? Let's go with that for now.------------
# 
# # !is.na(match(rownames(betas_clean6),anno_EPIC$Name_))
# 
# # This create a subset of anno_EPIC limited to the CpGs name in beta_clean6
# # Also removed some columns (5-11, 20-23)
# anno_EPICSub <- anno_EPIC[match(rownames(betas_clean6),anno_EPIC$Name_), # Need debug----------------------------------
#                       c(1:4,12:19,24:ncol(anno_EPIC))]
# # Rownames should not have missing values
# # I don't have missing values in betas_clean6 rownames itself
# # Missing values in anno_EPICSub
# # anno_EPICSub has missing rownames at 15, 20 etc?
# a <- rownames(ann_lucas_sub)
# head(a, 20)
# # No missing in anno_EPIC$Name
# b <- rownames(anno_EPIC)
# head(b, 20)
# anno_EPICSub <- anno_EPIC[!is.na(match(rownames(betas_clean6),anno_EPIC$Name_)),
#                         # This (!is.na) limite to the "inner" rownames in both data
#                       c(1:4,12:19,24:ncol(anno_EPIC))]
# # check after fix
# a <- rownames(anno_EPICSub)
# head(a, 20)

# This subset and sort the CpGs name to match our methylation data
ann_lucas_sub <- annot[match(rownames(betas_clean6),annot$Name), # "cg00000109" "cg00000155" "cg00000158" "cg00000221"
                      c(1:4,12:19,24:ncol(annot))]
# rownames(betas_clean6) # "cg00000109" "cg00000155" "cg00000158" "cg00000221"
```
<br>

### C. DMPs
Extract the tables of differentially expressed CpGs for each comparison. The results shown refers to the comparison for "Yes" genital use of talc.   
All adjusted p.values are equal to 0.9999.
```{r topTable dmps, echo=TRUE, class.source = 'fold-hide'}
# DMPs <- topTable(fit2, num=Inf, coef=1, genelist=anno_EPICSub) # Original code
# head(DMPs)
# Get the top genes from the linear model for the "Yes" powder use factor
DMPs <- topTable(fit2, num = Inf, coef = "Yes", genelist = ann_lucas_sub, adjust.method = "BH") 
head(DMPs %>% select(IlmnID, P.Value, 
                     adj.P.Val, B, everything()))
```
B or B-statistic is the log-odds of differential methylation.

```{r save DMPs}
# write.table(DMPs, file=paste0("results/DMPs_", today(), ".csv"), sep=",", row.names=FALSE)
# write_rds(DMPs, file=paste0("results/DMPs_", today(), ".rds"))
# DMPs <- read_rds(paste0("results/DMPs_2025-10-17.rds"))
```

#### c. Plot
I am still plotting the sample-wise methylation levels for the top 4 differentially methylated CpG sites.
```{r plotting the sample-wise methylation levels, echo=TRUE, class.source = 'fold-hide'}
# plot the top 4 most significantly differentially methylated CpGs
# par(mfrow=c(2,2))
# sapply(rownames(DMPs)[1:4], function(cpg){
#   plotCpg(betas_clean6, 
#           cpg = cpg, 
#           pheno = phenoclean_subset$Complete.Barcode, 
#           ylab = "Beta values")
# })

# plot_cpg <- 
betas_clean6 %>% as_tibble(rownames = "cpgs_id") %>% 
  filter(cpgs_id %in% c(rownames(DMPs)[1:4])) %>% 
  pivot_longer(cols = -cpgs_id, names_to = "Complete.Barcode", values_to = "cpg_intensity") %>% 
  left_join(clock_data %>% select(Complete.Barcode, talcgen), by = "Complete.Barcode") %>% 
  ggplot(aes(x = Complete.Barcode, y = cpg_intensity, color = talcgen))+
  geom_point(size = 1)+
  facet_wrap(. ~ cpgs_id, scale = "free_y")+
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```
Result:   
It doesn't seem to have any significant methylation CpGs associated with genital powder use when using a simple model (intercept + genital powder use[No/Yes]).   
<br>

### D. Volcano plot
Let's look at the CpGs with the most variability. For this, we select the CpGs which has the highest variance (top 10%) between samples, run the lmFit and Bayes models, and look at the resulting raw p-values on volcano plot.
```{r Volcano plot, fig.height=6, echo=TRUE, class.source = 'fold-hide'}
# 1. Subset to 10% most variable CpGs
row_vars <- apply(betas_clean6, 1, var, na.rm = TRUE)
top_10_cutoff <- quantile(row_vars, 0.90)
beta_top <- betas_clean6[row_vars >= top_10_cutoff, ]

# 2. Limma regression model
# Make sure Talc_yes is a factor (optional: set reference level)
clock_data$talcgen <- factor(clock_data$talcgen, levels = c("No", "Yes"))

# Design matrix with intercept and covariates
design <- model.matrix(~1 + talcgen, data = clock_data)

# Fit the model
fit <- lmFit(beta_top, design)
fit <- eBayes(fit)

# Extract results for the second coefficient: Talc_yes
results_10var <- topTable(fit, coef = 2, adjust = "fdr", number = Inf) # Without annotation------------

# 3. Add annotation from .rda file
# Merge annotation (matching by CpG IDs)
# results rownames = CpG IDs; annot$Name = CpG IDs
results_10var$CpG <- rownames(results_10var)

# Subset annotation to CpGs present in results
annot_subset <- annot[annot$Name %in% results_10var$CpG, ]

# Merge by CpG ID
#Check that the x and y names match
results_10var_annot <- merge(results_10var, annot_subset[, c("Name", "UCSC_RefGene_Name")],
                       by.x = "CpG", by.y = "Name", all.x = TRUE)

# Optional: clean up missing genes
#results_10var_annot$UCSC_RefGene_Name[is.na(results_10var_annot$UCSC_RefGene_Name)] <- ""

# 4. Create EnhancedVolcano Plot

EnhancedVolcano(results_10var_annot,
                lab = results_10var_annot$UCSC_RefGene_Name,
                x = 'logFC',
                y = 'P.Value',
                pCutoff = 0.01,
                FCcutoff = 0.1,
                title = 'Differential Methylation: Talc (Yes)',
                subtitle = 'Top 10% Most Variable CpGs',
                caption = 'LogFC vs p-value',
                pointSize = 2.5,
                labSize = 3.0)

EnhancedVolcano(results_10var_annot,
                lab = results_10var_annot$UCSC_RefGene_Name,
                x = 'logFC',
                y = 'P.Value',
                xlim = c(-0.5, 0.5),
                ylim = c(0, 5),
                pCutoff = 0.01,
                FCcutoff = 0.1,
                title = 'Differential Methylation: Talc (Yes)',
                subtitle = 'Top 10% Most Variable CpGs',
                caption = 'LogFC vs p-value',
                pointSize = 2.5,
                labSize = 3.0)
```

@Lucas, below volcano plots gives a different result, the points are the same but the names don't seem to match...

It is using another way to subset the annotation. The merge seems to work fine though...   
```{r other Volcano plot, fig.height=6, echo=TRUE, class.source = 'fold-hide'}
ann_10var <- annot[match(rownames(beta_top),annot$Name), # "cg00000109" "cg00000155" "cg00000158" "cg00000221"
                      c(1:4,12:19,24:ncol(annot))]
results_10var2 <- topTable(fit, coef = 2, genelist = ann_10var, adjust = "fdr", number = Inf)
head(results_10var2)
EnhancedVolcano(results_10var2,
                lab = results_10var2$UCSC_RefGene_Name,
                x = 'logFC',
                y = 'P.Value',
                pCutoff = 0.01,
                FCcutoff = 0.1,
                title = 'Differential Methylation: Talc (Yes)',
                subtitle = 'Top 10% Most Variable CpGs',
                caption = 'LogFC vs p-value',
                pointSize = 2.5,
                labSize = 3.0)

EnhancedVolcano(results_10var2,
                lab = results_10var2$UCSC_RefGene_Name,
                x = 'logFC',
                y = 'P.Value',
                xlim = c(-0.5, 0.5),
                ylim = c(0, 5),
                pCutoff = 0.01,
                FCcutoff = 0.1,
                title = 'Differential Methylation: Talc (Yes)',
                subtitle = 'Top 10% Most Variable CpGs',
                caption = 'LogFC vs p-value',
                pointSize = 2.5,
                labSize = 3.0)

```
There are CpGs showing good p value if we limit the number of multiple testing.

<br>

*** 
<br>

# II. Investigate CpGs Enrichment with Ranking p value

## 1. Enrichment adjusting for number of probes with methylGSA
This is using GO.
```{r pvals, echo=TRUE, class.source = 'fold-hide'}
# gene-level stats
gene.pvals <- DMPs$P.Value 
names(gene.pvals) <- DMPs$Name # names are cpgs
```

With the default argument
```{r ora.results_default, echo=TRUE, class.source = 'fold-hide'}
library(methylGSA)
# Run ORA
ora.results_default <- methylglm(gene.pvals,
                                 array.type = "EPIC",
                                 # minsize = 100, maxsize = 500,
                                 GS.type = "GO"#, # "GO" or "KEGG"
                                 # parallel = TRUE
)  
str(ora.results_default)
head(ora.results_default, 10)
```

With the updated argument
```{r ora.results, echo=TRUE, class.source = 'fold-hide'}
ora.results <- methylglm(gene.pvals,
                         array.type = "EPIC",
                         minsize = 20, maxsize = 500,
                         GS.type = "GO"#, # "GO" or "KEGG"
                         # parallel = TRUE
)  
str(ora.results)
head(ora.results, 10)
```
The initial result with applying the default `minsize = 100, maxsize = 500` arguments include `r nrow(ora.results_default)` CpGs which is then increased to `r nrow(ora.results)` CpGs after applying the `minsize` and `maxsize` argument.

<br>

## 2. Enrichment after adjusting multiple p-values of each gene by Robust Rank Aggregation using the ORA method
This uses `minsize = 20, maxsize = 500`
```{r ora.methylRRA, echo=TRUE, class.source = 'fold-hide'}
ora.methylRRA <- methylGSA::methylRRA(gene.pvals,
                                     method = "ORA", # "ORA" or "GSEA", GSEA doesn't work
                                     minsize = 20, maxsize = 500,
                                     array.type = "EPIC",
                                     GS.type = "GO")
str(ora.methylRRA)
head(ora.methylRRA, 10)
```
<br>

## 3. Enrichment after adjusting multiple p-values of each gene by Robust Rank Aggregation using the GSEA method
This uses `minsize = 20, maxsize = 500`
```{r gsea.methylRRA, echo=TRUE, class.source = 'fold-hide'}
gsea.methylRRA <- methylGSA::methylRRA(gene.pvals,
                                     method = "GSEA", # "ORA" or "GSEA", GSEA doesn't work
                                     minsize = 20, maxsize = 500,
                                     array.type = "EPIC",
                                     GS.type = "GO")
str(gsea.methylRRA)
head(gsea.methylRRA, 10)
```
<br>

***

<br>


# III. Gene ontology analysis using the whole methylation dataset
## 1. CpG level analysis
### A. How many CpGs are significantly modified?
For a significance at P.Val < 0.01
```{r significantly modified, echo=TRUE, class.source = 'fold-hide'}
# We can use the results from topTable we had previously
# DMPs <- topTable(fit2, num = Inf, coef = "Yes", genelist = ann_lucas_sub, adjust.method = "BH") 
# Get the significant CpG sites at P.Val<0.05
sigCpGs <- DMPs$Name[DMPs$P.Val<0.01]
# First 10 significant CpGs
sigCpGs[1:10]

# Total number of significant CpGs at 5% FDR
length(sigCpGs)

# Get all the CpG sites used in the analysis to form the background
all <- DMPs$Name
# Total number of CpG sites tested
length(all)
```
So `r length(sigCpGs)` CpGs are significant over `r length(all)` CpGs tested.   

### B. Let's look at the top GO ontology using missMethyl
These are the first 10 unordered rows.
```{r gst_go, echo=TRUE, class.source = 'fold-hide'}
library(missMethyl)
par(mfrow=c(1,1))
gst_go <- gometh(sig.cpg=sigCpGs, all.cpg=all, 
                 plot.bias=TRUE, array.type = "EPIC", 
                 collection = "GO")
gst_go[1:10,]
```

Let's filter out the ones with occurence < 20 and > 500.
```{r, echo=TRUE, class.source = 'fold-hide'}
ordered_gst_go <- gst_go %>% 
  filter(N >= 20 & N <= 500) %>% 
  select(TERM, N, DE, P.DE, FDR, everything()) %>% 
  arrange(P.DE)
head(ordered_gst_go)
write_csv(ordered_gst_go %>% filter(ONTOLOGY == "BP"), 
          paste0(here::here(), "/results/",
          "missMethyl_gometh gene ontology enrichment for significant CpGs gst in BP ontology.csv"))
write_csv(ordered_gst_go %>% filter(ONTOLOGY == "CC"), 
          paste0(here::here(), "/results/",
          "missMethyl_gometh gene ontology enrichment for significant CpGs gst in CC ontology.csv"))
write_csv(ordered_gst_go %>% filter(ONTOLOGY == "MF"), 
          paste0(here::here(), "/results/",
          "missMethyl_gometh gene ontology enrichment for significant CpGs gst in MF ontology.csv"))
```

These are the top 20 most significantly enriched pathways using topGSA. The output is ordered by p-value. There is a slight difference compared to doing it manually like I have done above.
```{r, echo=TRUE, class.source = 'fold-hide'}
topGSA(gst_go)
```

### C. Let's look at the top KEGG ontology using missMethyl
```{r gometh, echo=TRUE, class.source = 'fold-hide'}
gst_kegg <- gometh(sig.cpg=sigCpGs, all.cpg=all, 
                   plot.bias=TRUE, array.type = "EPIC", 
                   collection = "KEGG")
topGSA(gst_kegg)
```
<br>

## B.Gene set testing
It seemed that the top significant CpGs are present within similar gene pathways (positional), so it is more comprehensive to group the CpGs into gene sets.
Download C1: positional gene sets Human MSigDB Collections.    
https://www.gsea-msigdb.org/gsea/msigdb/human/collections.jsp#C1

Above are the top 20 most significantly enriched gene sets using topGSA.
```{r hallmark_gene_sets, echo=TRUE, class.source = 'fold-hide'}
# https://www.gsea-msigdb.org/gsea/msigdb/download_file.jsp?filePath=/msigdb/release/2025.1.Hs/c1.all.v2025.1.Hs.symbols.gmt
# hallmark_gene_sets <- GSA.read.gmt(paste0(here::here(), # Read as a list of list - not working with gsameth
#                                           "/data/raw data",
#                                           "/c1.all.v2025.1.Hs.entrez.gmt"))

library(BAGS)
hallmark_gene_sets <- ReadGMT(
  paste0(here::here(),
         "/data/raw data",
         "/c1.all.v2025.1.Hs.entrez.gmt"))

# anno_EPIC = getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
library(GSA)

#top <- topRUV(fit2, number = Inf)

# gsa_illum <- gsameth(sig.cpg = sigCpGs, all.cpg = all, # The results is the same as below but without SigGenesInSet column
#                collection = hallmark_gene_sets,
#                # genomic.features = "Body",
#                # prior.prob = TRUE, 
#                anno = annotDF,
#                # plot.bias = TRUE,
#                array.type = "EPIC")
# topGSA(gsa_illum, n = 10)

gsa_lucas <- gsameth(sig.cpg = sigCpGs, all.cpg = all, 
               collection = hallmark_gene_sets,
               # genomic.features = "Body",
               # prior.prob = TRUE, 
               anno = annot,
               # plot.bias = TRUE,
               array.type = "EPIC",
               sig.genes = TRUE)
topGSA(gsa_lucas)
```
<br>

***
<br>

# IV. Differential methylation analysis of regions
Instead of doing probe-wise analysis, we could look at methylated regions using `dmrcate`.

Text from paper:   
Firstly, our matrix of M-values is annotated with the relevant information about the probes such as their genomic position, gene annotation, etc. By default, this is done using the `ilmn12.hg19` annotation, but this can be substituted for any argument compatible with the interface provided by the *minfi* package. The *limma* pipeline is then used for differential methylation analysis to calculate moderated t-statistics.

I don't see an argument for `ilmn12.hg19`?????




Annotate our beta values matrix.    
As we saw before all the p values are = 0.9999.   
Increasing the fdr to > 0.05 lead to the warning message `Your contrast returned no individually significant probes. Try increasing the fdr. Alternatively, set pcutoff manually in dmrcate() to return DMRs, but be warned there is an increased risk of Type I errors.`. We would probably need to set the fdr at 0.9999 to get significance here and then everything would be significant.   
Instead, I then set `pcutoff = 0.05` in the `dmrcate()` function.



Should i use the argument `epicv2Remap`?????
```{r cpgannotate, echo=TRUE, class.source = 'fold-hide'}
library(DMRcate)
# myAnnotation <- cpg.annotate(object = mVals, datatype = "array", what = "M", # Original code
#                              analysis.type = "differential", design = design,
#                              contrasts = TRUE, cont.matrix = contMatrix,
#                              coef = "naive - rTreg", arraytype = "450K")
myAnnotation <- cpg.annotate(object = betas_clean6, datatype = "array", what = "Beta",
                             analysis.type = "differential", design = design,
                             # contrasts = TRUE, cont.matrix = contMatrix,
                             coef = 2, arraytype = "EPICv1",
                             fdr = 0.95)
str(myAnnotation)
```
We have now the relevant statistics for the individual CpGs.    
Combine them to identify differentially methylated regions using the `dmrcate` function. The main output table `DMRs$results` contains all of the regions found, along with their genomic annotations and p-values.

```{r dmrcate, echo=TRUE, class.source = 'fold-hide'}
DMRs_regions <- dmrcate(myAnnotation, lambda=1000, C=2, pcutoff = 0.01, min.cpgs = 5)
# head(DMRs$results) # Original code -> This doesn't work 
bind_cols(as.data.frame(DMRs_regions@coord), as.data.frame(DMRs_regions@no.cpgs),
          as.data.frame(DMRs_regions@min_smoothed_fdr), as.data.frame(DMRs_regions@Stouffer),
          as.data.frame(DMRs_regions@HMFDR), as.data.frame(DMRs_regions@Fisher),
          as.data.frame(DMRs_regions@maxdiff), as.data.frame(DMRs_regions@meandiff))
```

Visualise the results / regions using the `DMR.plot`.
```{r resultsranges, echo=TRUE, class.source = 'fold-hide'}
# convert the regions to annotated genomic ranges
# data(dmrcatedata)
results.ranges <- extractRanges(DMRs_regions, genome = "hg38")
results.ranges
# set up the grouping variables and colours
# groups <- pal[1:length(unique(targets$Sample_Group))] # Original code
# names(groups) <- levels(factor(targets$Sample_Group))
# cols <- groups[as.character(factor(targets$Sample_Group))]
# samps <- 1:nrow(targets)

groups <- c("blue", "red") # pal[1:length(unique(clock_data$talcgen))]
names(groups) <- levels(factor(clock_data$talcgen))
cols <- groups[as.character(factor(clock_data$talcgen))]
samps <- 1:nrow(clock_data)
```

There are `r results.ranges@elementMetadata@nrows` differentially methylated regions.
```{r figure range, fig.width=10, fig.height=10, echo=TRUE, class.source = 'fold-hide'}
# draw the plot for the top DMR
# par(mfrow=c(1,1))
# DMR.plot(ranges = results.ranges, dmr = 1, 
#          CpGs = betas_clean6, #[1:100, 1:6], 
#          phen.col = cols, what = "Beta",
#          arraytype = "EPICv1", 
#          # pch=16, toscale=TRUE, plotmedians=TRUE,
#          genome="hg38",# samps=samps
#          heatmap = FALSE
#          )

# There are only 15 chr so let's plot them all
for (i in 1:results.ranges@elementMetadata@nrows) {
  DMR.plot(ranges = results.ranges, dmr = i, 
         CpGs = betas_clean6, #[1:100, 1:6], 
         phen.col = cols, what = "Beta",
         arraytype = "EPICv1", 
         # pch=16, toscale=TRUE, plotmedians=TRUE,
         genome="hg38",# samps=samps
         heatmap = FALSE
         )
}

```




<br>

***
